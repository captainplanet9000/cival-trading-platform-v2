from sqlalchemy.orm import Session
from sqlalchemy import select, desc, asc
from typing import Callable, List, Optional
from datetime import datetime, timezone
import uuid # For default snapshot_id if needed, though model handles it

# Adjust import paths based on your project structure
from ..core.database import SessionLocal # Example, direct use of SessionLocal might vary
from ..models.db_models import PortfolioSnapshotDB
from ..models.dashboard_models import PortfolioSnapshotOutput
from ..models.event_bus_models import Event # For publishing
from ..services.event_bus_service import EventBusService # For publishing
from loguru import logger

class PortfolioSnapshotServiceError(Exception):
    """Custom exception for PortfolioSnapshotService."""
    pass

class PortfolioSnapshotService:
    def __init__(self, session_factory: Callable[[], Session], event_bus: Optional[EventBusService] = None):
        self.session_factory = session_factory
        self.event_bus = event_bus
        logger.info("PortfolioSnapshotService initialized.")
        if self.event_bus:
            logger.info("EventBusService available to PortfolioSnapshotService for publishing events.")
        else:
            logger.warning("EventBusService not available to PortfolioSnapshotService. Snapshot events will not be published.")

    async def record_snapshot(
        self, agent_id: str, total_equity_usd: float, timestamp: Optional[datetime] = None
    ) -> PortfolioSnapshotOutput:
        if timestamp is None:
            timestamp = datetime.now(timezone.utc)
        elif timestamp.tzinfo is None: # Ensure timestamp is timezone-aware (UTC)
            timestamp = timestamp.replace(tzinfo=timezone.utc)

        # snapshot_id is generated by default in the DB model
        db_snapshot = PortfolioSnapshotDB(
            agent_id=agent_id,
            total_equity_usd=total_equity_usd,
            timestamp=timestamp
        )

        db: Session = self.session_factory()
        try:
            db.add(db_snapshot)
            db.commit()
            db.refresh(db_snapshot) # To get any DB-generated values like default snapshot_id
            logger.info(f"Recorded portfolio snapshot for agent {agent_id} at {timestamp.isoformat()} with equity {total_equity_usd:.2f}. Snapshot ID: {db_snapshot.snapshot_id}")

            pydantic_snapshot = PortfolioSnapshotOutput.from_orm(db_snapshot)

            if self.event_bus:
                # Payload for the event is the Pydantic model of the snapshot taken
                event_payload_dict = pydantic_snapshot.model_dump(mode='json') # Ensure datetimes are serialized
                event_to_publish = Event(
                    publisher_agent_id=agent_id, # Or a system ID like "PortfolioSnapshotService"
                    message_type="PortfolioSnapshotTakenEvent",
                    payload=event_payload_dict
                )
                await self.event_bus.publish(event_to_publish)
                logger.debug(f"Published PortfolioSnapshotTakenEvent for agent {agent_id}, snapshot_id {db_snapshot.snapshot_id}")

            return pydantic_snapshot
        except Exception as e:
            db.rollback()
            logger.error(f"Error recording portfolio snapshot for agent {agent_id}: {e}", exc_info=True)
            raise PortfolioSnapshotServiceError(f"Failed to record portfolio snapshot: {e}")
        finally:
            db.close()

    async def get_historical_snapshots(
        self, agent_id: str,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        limit: Optional[int] = 1000,
        sort_ascending: bool = True # Default to chronological order
    ) -> List[PortfolioSnapshotOutput]:
        db: Session = self.session_factory()
        logger.debug(f"Fetching historical snapshots for agent {agent_id} from {start_time} to {end_time}, limit {limit}, asc {sort_ascending}")
        try:
            stmt = select(PortfolioSnapshotDB).where(PortfolioSnapshotDB.agent_id == agent_id)

            if start_time:
                if start_time.tzinfo is None: start_time = start_time.replace(tzinfo=timezone.utc)
                stmt = stmt.where(PortfolioSnapshotDB.timestamp >= start_time)
            if end_time:
                if end_time.tzinfo is None: end_time = end_time.replace(tzinfo=timezone.utc)
                stmt = stmt.where(PortfolioSnapshotDB.timestamp <= end_time)

            if sort_ascending:
                stmt = stmt.order_by(asc(PortfolioSnapshotDB.timestamp))
            else:
                stmt = stmt.order_by(desc(PortfolioSnapshotDB.timestamp))

            if limit is not None:
                stmt = stmt.limit(limit)

            results = db.execute(stmt).scalars().all()
            logger.info(f"Retrieved {len(results)} portfolio snapshots for agent {agent_id}.")
            return [PortfolioSnapshotOutput.from_orm(res) for res in results]
        except Exception as e:
            logger.error(f"Error fetching historical snapshots for agent {agent_id}: {e}", exc_info=True)
            raise PortfolioSnapshotServiceError(f"Failed to fetch historical snapshots: {e}")
        finally:
            db.close()
