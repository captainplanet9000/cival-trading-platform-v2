"""
Phase 10: Advanced Multi-Agent Trading Strategy Models
Sophisticated trading strategies, market analysis, and portfolio coordination
"""

import uuid
from typing import Dict, List, Optional, Any, Union, Literal, Tuple
from datetime import datetime, timezone, timedelta
from decimal import Decimal
from enum import Enum
from pydantic import BaseModel, Field, validator
import json

# Trading Strategy Enums

class StrategyType(str, Enum):
    """Trading strategy types"""
    MOMENTUM = "momentum"
    MEAN_REVERSION = "mean_reversion"
    ARBITRAGE = "arbitrage"
    MARKET_MAKING = "market_making"
    BREAKOUT = "breakout"
    SCALPING = "scalping"
    SWING = "swing"
    GRID = "grid"
    DCA = "dca"  # Dollar Cost Averaging
    PAIRS = "pairs"
    STATISTICAL_ARBITRAGE = "statistical_arbitrage"
    NEWS_SENTIMENT = "news_sentiment"
    TECHNICAL_INDICATOR = "technical_indicator"
    MACHINE_LEARNING = "machine_learning"
    MULTI_FACTOR = "multi_factor"

class MarketCondition(str, Enum):
    """Market condition classifications"""
    BULLISH = "bullish"
    BEARISH = "bearish"
    SIDEWAYS = "sideways"
    VOLATILE = "volatile"
    LOW_VOLATILITY = "low_volatility"
    HIGH_VOLATILITY = "high_volatility"
    TRENDING = "trending"
    CONSOLIDATING = "consolidating"

class SignalStrength(str, Enum):
    """Trading signal strength levels"""
    VERY_WEAK = "very_weak"
    WEAK = "weak"
    MODERATE = "moderate"
    STRONG = "strong"
    VERY_STRONG = "very_strong"

class PositionSide(str, Enum):
    """Position side"""
    LONG = "long"
    SHORT = "short"
    NEUTRAL = "neutral"

class OrderType(str, Enum):
    """Order types"""
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"
    TRAILING_STOP = "trailing_stop"
    ICEBERG = "iceberg"
    TWAP = "twap"
    VWAP = "vwap"

class RiskLevel(str, Enum):
    """Risk level classifications"""
    VERY_LOW = "very_low"
    LOW = "low"
    MODERATE = "moderate"
    HIGH = "high"
    VERY_HIGH = "very_high"

# Core Trading Models

class TradingSignal(BaseModel):
    """Trading signal generated by strategy"""
    signal_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    strategy_id: str
    agent_id: str
    symbol: str
    signal_type: str  # buy, sell, hold
    strength: SignalStrength
    confidence: float = Field(ge=0.0, le=1.0)
    
    # Signal details
    entry_price: Optional[Decimal] = None
    target_price: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    quantity: Optional[Decimal] = None
    position_side: PositionSide
    
    # Context
    timeframe: str
    market_condition: MarketCondition
    technical_indicators: Dict[str, float] = Field(default_factory=dict)
    fundamental_factors: Dict[str, Any] = Field(default_factory=dict)
    
    # Metadata
    generated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    expires_at: Optional[datetime] = None
    priority: int = Field(ge=1, le=10, default=5)
    
    # Validation
    min_market_cap: Optional[Decimal] = None
    max_spread: Optional[float] = None
    required_volume: Optional[Decimal] = None

class MarketData(BaseModel):
    """Market data snapshot"""
    symbol: str
    timestamp: datetime
    
    # Price data
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: Decimal
    
    # Additional metrics
    vwap: Optional[Decimal] = None
    twap: Optional[Decimal] = None
    bid: Optional[Decimal] = None
    ask: Optional[Decimal] = None
    spread: Optional[float] = None
    
    # Technical indicators
    rsi: Optional[float] = None
    macd: Optional[Dict[str, float]] = None
    bollinger_bands: Optional[Dict[str, float]] = None
    moving_averages: Dict[str, float] = Field(default_factory=dict)
    
    # Market metrics
    market_cap: Optional[Decimal] = None
    circulating_supply: Optional[Decimal] = None
    volatility: Optional[float] = None

class TradingPosition(BaseModel):
    """Trading position"""
    position_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    strategy_id: str
    agent_id: str
    symbol: str
    
    # Position details
    side: PositionSide
    quantity: Decimal
    entry_price: Decimal
    current_price: Optional[Decimal] = None
    
    # Risk management
    stop_loss: Optional[Decimal] = None
    take_profit: Optional[Decimal] = None
    trailing_stop_distance: Optional[float] = None
    
    # Status
    status: str = "open"  # open, closed, partial
    opened_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    closed_at: Optional[datetime] = None
    
    # Performance
    unrealized_pnl: Decimal = Decimal("0")
    realized_pnl: Decimal = Decimal("0")
    fees_paid: Decimal = Decimal("0")
    
    # Metadata
    tags: List[str] = Field(default_factory=list)
    notes: str = ""

class TradingStrategy(BaseModel):
    """Trading strategy definition"""
    strategy_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    description: str
    strategy_type: StrategyType
    
    # Configuration
    parameters: Dict[str, Any] = Field(default_factory=dict)
    timeframes: List[str] = Field(default_factory=list)
    symbols: List[str] = Field(default_factory=list)
    
    # Risk management
    max_position_size: Decimal
    max_portfolio_allocation: float = Field(ge=0.0, le=1.0)
    risk_level: RiskLevel
    stop_loss_percentage: Optional[float] = None
    take_profit_percentage: Optional[float] = None
    
    # Market conditions
    preferred_conditions: List[MarketCondition] = Field(default_factory=list)
    min_volatility: Optional[float] = None
    max_volatility: Optional[float] = None
    
    # Performance targets
    target_sharpe_ratio: Optional[float] = None
    max_drawdown: Optional[float] = None
    target_win_rate: Optional[float] = None
    
    # Status
    active: bool = True
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    last_modified: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    
    # Backtesting results
    backtest_results: Optional[Dict[str, Any]] = None
    live_performance: Optional[Dict[str, Any]] = None

class PortfolioAllocation(BaseModel):
    """Portfolio allocation strategy"""
    allocation_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    portfolio_id: str
    
    # Strategy allocations
    strategy_allocations: Dict[str, float] = Field(default_factory=dict)  # strategy_id -> weight
    symbol_allocations: Dict[str, float] = Field(default_factory=dict)   # symbol -> weight
    
    # Risk constraints
    max_single_position: float = Field(ge=0.0, le=1.0, default=0.1)
    max_sector_exposure: float = Field(ge=0.0, le=1.0, default=0.3)
    max_correlation: float = Field(ge=0.0, le=1.0, default=0.7)
    
    # Rebalancing
    rebalance_frequency: str = "daily"  # daily, weekly, monthly
    rebalance_threshold: float = 0.05  # 5% deviation
    
    # Target metrics
    target_volatility: Optional[float] = None
    target_return: Optional[float] = None
    max_drawdown_limit: float = 0.2  # 20%
    
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    last_rebalanced: Optional[datetime] = None

class MultiAgentCoordination(BaseModel):
    """Multi-agent coordination configuration"""
    coordination_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    
    # Participating strategies/agents
    participating_strategies: List[str] = Field(default_factory=list)
    coordinator_agent_id: str
    
    # Coordination rules
    signal_aggregation: str = "weighted_average"  # majority_vote, weighted_average, consensus
    conflict_resolution: str = "priority_based"   # priority_based, risk_adjusted, performance_based
    
    # Signal handling
    min_signal_consensus: float = Field(ge=0.0, le=1.0, default=0.6)
    signal_timeout: int = 300  # seconds
    
    # Risk management
    aggregate_position_limits: Dict[str, float] = Field(default_factory=dict)
    correlation_monitoring: bool = True
    max_simultaneous_trades: int = 10
    
    # Performance tracking
    coordination_performance: Dict[str, float] = Field(default_factory=dict)
    
    active: bool = True
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ArbitrageOpportunity(BaseModel):
    """Arbitrage opportunity detection"""
    opportunity_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    
    # Opportunity details
    arbitrage_type: str  # spatial, temporal, triangular, statistical
    symbols: List[str]
    exchanges: List[str]
    
    # Price differences
    price_differential: Decimal
    percentage_spread: float
    expected_profit: Decimal
    
    # Execution requirements
    minimum_volume: Decimal
    execution_window: int  # seconds
    required_capital: Decimal
    
    # Risk factors
    execution_risk: float = Field(ge=0.0, le=1.0)
    liquidity_risk: float = Field(ge=0.0, le=1.0)
    timing_risk: float = Field(ge=0.0, le=1.0)
    
    # Status
    detected_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    expires_at: datetime
    status: str = "active"  # active, executed, expired
    
    # Validation
    confidence_score: float = Field(ge=0.0, le=1.0)
    historical_success_rate: Optional[float] = None

class RiskMetrics(BaseModel):
    """Risk management metrics"""
    portfolio_id: str
    calculation_timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    
    # Portfolio metrics
    total_value: Decimal
    total_exposure: Decimal
    leverage: float
    
    # Risk measures
    var_1day: Decimal  # Value at Risk
    var_5day: Decimal
    expected_shortfall: Decimal
    max_drawdown: float
    current_drawdown: float
    
    # Volatility metrics
    portfolio_volatility: float
    beta: Optional[float] = None
    correlation_matrix: Dict[str, Dict[str, float]] = Field(default_factory=dict)
    
    # Concentration risk
    largest_position_weight: float
    top_5_concentration: float
    sector_concentrations: Dict[str, float] = Field(default_factory=dict)
    
    # Liquidity metrics
    liquidity_score: float = Field(ge=0.0, le=1.0)
    days_to_liquidate: float
    
    # Performance attribution
    strategy_contributions: Dict[str, float] = Field(default_factory=dict)
    factor_exposures: Dict[str, float] = Field(default_factory=dict)

class StrategyPerformance(BaseModel):
    """Strategy performance analytics"""
    strategy_id: str
    performance_period: str  # daily, weekly, monthly, quarterly, yearly
    start_date: datetime
    end_date: datetime
    
    # Return metrics
    total_return: float
    annualized_return: float
    excess_return: float  # vs benchmark
    
    # Risk metrics
    volatility: float
    sharpe_ratio: float
    sortino_ratio: float
    calmar_ratio: float
    
    # Drawdown analysis
    max_drawdown: float
    average_drawdown: float
    drawdown_duration: int  # days
    
    # Trade statistics
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    average_win: float
    average_loss: float
    profit_factor: float
    
    # Risk-adjusted metrics
    information_ratio: float
    treynor_ratio: float
    jensen_alpha: float
    
    # Consistency metrics
    monthly_returns: List[float] = Field(default_factory=list)
    hit_ratio: float  # percentage of positive periods
    
    calculated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class MarketRegime(BaseModel):
    """Market regime classification"""
    regime_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    
    # Regime characteristics
    regime_name: str
    market_condition: MarketCondition
    volatility_level: str  # low, medium, high
    trend_direction: str   # up, down, sideways
    
    # Market metrics
    average_volatility: float
    correlation_levels: Dict[str, float] = Field(default_factory=dict)
    liquidity_conditions: str  # high, medium, low
    
    # Strategy performance in regime
    strategy_performance: Dict[str, float] = Field(default_factory=dict)
    recommended_strategies: List[str] = Field(default_factory=list)
    strategies_to_avoid: List[str] = Field(default_factory=list)
    
    # Regime detection
    confidence: float = Field(ge=0.0, le=1.0)
    detection_signals: List[str] = Field(default_factory=list)
    
    # Timing
    detected_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    expected_duration: Optional[timedelta] = None
    
    # Historical analysis
    historical_frequency: Optional[float] = None
    average_duration_days: Optional[float] = None

class AdaptiveLearning(BaseModel):
    """Adaptive learning configuration for strategies"""
    learning_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    strategy_id: str
    
    # Learning parameters
    learning_rate: float = Field(ge=0.0, le=1.0, default=0.01)
    adaptation_frequency: str = "daily"  # real_time, hourly, daily, weekly
    lookback_period: int = 30  # days
    
    # Feature selection
    features_to_monitor: List[str] = Field(default_factory=list)
    feature_importance: Dict[str, float] = Field(default_factory=dict)
    
    # Model parameters
    model_type: str = "ensemble"  # linear, tree, neural_network, ensemble
    retrain_threshold: float = 0.05  # performance degradation threshold
    
    # Performance tracking
    prediction_accuracy: float = 0.0
    adaptation_history: List[Dict[str, Any]] = Field(default_factory=list)
    
    # Configuration
    auto_adaptation: bool = True
    require_approval: bool = False
    min_confidence_threshold: float = 0.7
    
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    last_adaptation: Optional[datetime] = None

# Request/Response Models

class StrategyBacktestRequest(BaseModel):
    """Strategy backtesting request"""
    strategy_id: str
    start_date: datetime
    end_date: datetime
    initial_capital: Decimal = Decimal("100000")
    
    # Backtest configuration
    benchmark: str = "BTC"
    commission: float = 0.001  # 0.1%
    slippage: float = 0.001    # 0.1%
    
    # Data configuration
    data_frequency: str = "1h"  # 1m, 5m, 15m, 1h, 4h, 1d
    warmup_period: int = 100   # bars
    
    # Risk parameters
    max_leverage: float = 1.0
    margin_requirements: Dict[str, float] = Field(default_factory=dict)
    
    # Output configuration
    detailed_trades: bool = True
    include_drawdown_analysis: bool = True
    generate_charts: bool = True

class MultiStrategyPortfolioRequest(BaseModel):
    """Multi-strategy portfolio creation request"""
    portfolio_name: str
    strategies: List[str]  # strategy_ids
    initial_capital: Decimal
    
    # Allocation method
    allocation_method: str = "equal_weight"  # equal_weight, risk_parity, optimization
    rebalancing_frequency: str = "weekly"
    
    # Risk constraints
    max_position_size: float = 0.1
    max_sector_exposure: float = 0.3
    target_volatility: Optional[float] = None
    
    # Coordination settings
    enable_signal_coordination: bool = True
    conflict_resolution: str = "risk_adjusted"

class LiveTradingRequest(BaseModel):
    """Live trading activation request"""
    strategy_id: str
    allocated_capital: Decimal
    
    # Trading parameters
    max_position_size: Decimal
    risk_per_trade: float = 0.02  # 2%
    
    # Execution settings
    order_type: OrderType = OrderType.LIMIT
    execution_timeout: int = 300  # seconds
    
    # Risk management
    daily_loss_limit: Decimal
    max_open_positions: int = 5
    
    # Approval workflow
    require_manual_approval: bool = False
    auto_start: bool = True

class SignalGenerationRequest(BaseModel):
    """Signal generation request"""
    strategy_ids: List[str]
    symbols: List[str]
    timeframe: str = "1h"
    
    # Analysis parameters
    lookback_period: int = 100
    min_confidence: float = 0.6
    
    # Market data
    include_technical_indicators: bool = True
    include_fundamental_data: bool = False
    include_sentiment_data: bool = False
    
    # Output filtering
    max_signals: int = 10
    min_signal_strength: SignalStrength = SignalStrength.MODERATE

# Export all models
__all__ = [
    # Enums
    "StrategyType", "MarketCondition", "SignalStrength", "PositionSide", "OrderType", "RiskLevel",
    
    # Core Models
    "TradingSignal", "MarketData", "TradingPosition", "TradingStrategy", "PortfolioAllocation",
    "MultiAgentCoordination", "ArbitrageOpportunity", "RiskMetrics", "StrategyPerformance",
    "MarketRegime", "AdaptiveLearning",
    
    # Request/Response Models
    "StrategyBacktestRequest", "MultiStrategyPortfolioRequest", "LiveTradingRequest",
    "SignalGenerationRequest"
]