from pydantic import BaseModel, Field, field_validator
from typing import List, Dict, Any, Optional, Literal # Added Literal for SignalDataPoint
from datetime import date, datetime, timezone # Ensure timezone for default
import uuid

# Assuming TradeRecord is importable for paper_trades field
try:
    from .trading_history_models import TradeRecord
except ImportError:
    TradeRecord = Dict # Fallback

class OHLCVBar(BaseModel):
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: Optional[float] = None

class IndicatorDataPoint(BaseModel):
    timestamp: datetime
    value: Optional[float] = None # Some indicators might have NaN initially, made Optional
    # For multi-line indicators like MACD, 'value' could be a dict: e.g. {"macd": 1.0, "signal": 0.9, "histogram": 0.1}
    # Or, have separate series for each line. For simplicity, one value or dict of values.
    values: Optional[Dict[str, Optional[float]]] = None # For multi-line indicators

    @field_validator('value', 'values') # Updated to new Pydantic syntax
    @classmethod # Needs to be classmethod
    def check_one_value_source(cls, v, info): # info context instead of field and values directly
        # Corrected logic for Pydantic v2 field_validator
        # This validator is tricky because it needs to see both fields.
        # A root_validator might be more appropriate if direct cross-field validation in field_validator is complex.
        # For now, this structure might not work as intended in Pydantic v2 for cross-field validation.
        # Let's simplify: A model should be valid if it has value OR values, or neither (for truly missing data).
        # It's an issue if it has BOTH.
        # This will be checked at a higher level or by a root_validator if strictness is paramount.
        # The original validator logic was:
        # if field.name == 'value' and values.get('values') is not None and v is not None:
        #     raise ValueError("Cannot have both 'value' and 'values' fields populated.")
        # if field.name == 'values' and values.get('value') is not None and v is not None:
        #      raise ValueError("Cannot have both 'value' and 'values' fields populated.")
        # if values.get('value') is None and values.get('values') is None:
        #      # Allow both to be None if an indicator value is truly missing for a timestamp
        #      pass
        # For simplicity in this step, we'll assume the user of the model ensures only one is populated if not None.
        # A root validator would be:
        # @root_validator(skip_on_failure=True)
        # def check_value_or_values(cls, values_dict):
        #    value = values_dict.get('value')
        #    values_field = values_dict.get('values')
        #    if value is not None and values_field is not None:
        #        raise ValueError("Cannot have both 'value' and 'values' fields populated.")
        #    return values_dict
        return v


class SignalDataPoint(BaseModel):
    timestamp: datetime
    price_at_signal: float # Typically the close price of the signal bar
    signal_type: Literal["entry_long", "exit_long", "entry_short", "exit_short"] # More specific than just entry/exit
    # Optional: Add details like strategy_name or specific rule triggered if available

class StrategyVisualizationRequest(BaseModel):
    strategy_config_id: uuid.UUID = Field(..., description="ID of the strategy configuration to visualize.")
    # user_id: uuid.UUID Field is REMOVED - will come from authenticated token
    start_date: date = Field(..., description="Start date for the visualization period.")
    end_date: date = Field(..., description="End date for the visualization period.")
    # symbol: Optional[str] = Field(None, description="Specific symbol if strategy has multiple; defaults to first.") # StrategyConfig has symbols list
    user_id: Optional[uuid.UUID] = Field(default=None, description="User ID, to be populated from authenticated context, not client request.") # Added for service layer compatibility

    class Config: # Added Config to allow extra fields if needed, or validate assignment
        validate_assignment = True
        # extra = 'ignore' # Or 'forbid' depending on how strictly you want to handle incoming query params

class StrategyVisualizationDataResponse(BaseModel):
    strategy_config_id: uuid.UUID
    symbol_visualized: str
    period_start_date: date
    period_end_date: date
    ohlcv_data: List[OHLCVBar] = Field(default_factory=list)
    # Key is indicator name (e.g., "SMA_20", "RSI_14"), value is list of its data points over time
    indicator_data: Dict[str, List[IndicatorDataPoint]] = Field(default_factory=dict)
    # Entry/Exit signals from the strategy's logic
    entry_signals: List[SignalDataPoint] = Field(default_factory=list) # Generated by strategy logic
    exit_signals: List[SignalDataPoint] = Field(default_factory=list)  # Generated by strategy logic
    # Actual paper trades executed during this period for this strategy
    paper_trades: Optional[List[TradeRecord]] = Field(default_factory=list)

    generated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
